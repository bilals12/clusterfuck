apiVersion: apps/v1
kind: Deployment
metadata:
  name: payload-server
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payload-server
  template:
    metadata:
      labels:
        app: payload-server
    spec:
      containers:
      - name: payload-server
        image: bilals12/payload-server:latest
        securityContext:
          privileged: true
        command: ["/bin/bash", "-c"]
        args:
        - |
          # Create uploads directory
          mkdir -p /payloads/uploads
          mkdir -p /payloads/shells

          # Install netcat if not already present
          apt-get update && apt-get install -y netcat-openbsd netcat-traditional 2>/dev/null || true

          # Create a script to log reverse shell connections
          cat > /payloads/shell_logger.sh << 'EOT'
          #!/bin/bash
          PORT=$1
          LOG_FILE="/payloads/shells/shell_${PORT}_$(date +%s).log"
          
          echo "Starting listener on port $PORT, logging to $LOG_FILE"
          echo "Listener started at $(date)" > $LOG_FILE
          
          # First try with netcat-traditional (GNU netcat) which supports -e
          if command -v nc.traditional &> /dev/null; then
              echo "Using nc.traditional on port $PORT" | tee -a $LOG_FILE
              nc.traditional -l -p $PORT -v 2>&1 | tee -a $LOG_FILE
          # Then try with netcat-openbsd which supports -l
          elif command -v nc.openbsd &> /dev/null; then
              echo "Using nc.openbsd on port $PORT" | tee -a $LOG_FILE
              nc.openbsd -l -p $PORT -v 2>&1 | tee -a $LOG_FILE
          # Fall back to whatever nc is available
          else
              echo "Using default nc on port $PORT" | tee -a $LOG_FILE
              nc -l -p $PORT -v 2>&1 | tee -a $LOG_FILE
          fi
          
          echo "Listener on port $PORT exited at $(date)" >> $LOG_FILE
          # Automatically restart the listener
          exec $0 $PORT
          EOT
          
          chmod +x /payloads/shell_logger.sh
          
          # Create a basic HTTP server that logs more information
          cat > /payloads/server.py << 'EOT'
          #!/usr/bin/env python3
          import http.server
          import socketserver
          import os
          import cgi
          import json
          import base64
          from datetime import datetime

          PORT = 8080
          UPLOAD_DIR = "/payloads/uploads"

          os.makedirs(UPLOAD_DIR, exist_ok=True)

          class CustomHTTPRequestHandler(http.server.BaseHTTPRequestHandler):
              def _set_headers(self, status_code=200, content_type='text/html'):
                  self.send_response(status_code)
                  self.send_header('Content-type', content_type)
                  self.end_headers()
              
              def do_GET(self):
                  print(f"[{datetime.now()}] GET request received: {self.path}")
                  
                  if self.path == '/':
                      self.path = '/index.html'
                  
                  try:
                      file_path = f"/payloads{self.path}"
                      if os.path.exists(file_path) and os.path.isfile(file_path):
                          with open(file_path, 'rb') as file:
                              self._set_headers(200)
                              self.wfile.write(file.read())
                          print(f"[{datetime.now()}] Served file: {file_path}")
                      else:
                          self._set_headers(404)
                          self.wfile.write(b"File not found")
                          print(f"[{datetime.now()}] File not found: {file_path}")
                  except Exception as e:
                      self._set_headers(500)
                      self.wfile.write(str(e).encode())
                      print(f"[{datetime.now()}] Error: {e}")
              
              def do_POST(self):
                  print(f"[{datetime.now()}] POST request received: {self.path}")
                  
                  try:
                      form = cgi.FieldStorage(
                          fp=self.rfile,
                          headers=self.headers,
                          environ={'REQUEST_METHOD': 'POST'}
                      )
                      
                      timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                      print(f"[{datetime.now()}] Headers: {self.headers}")
                      
                      if 'file' in form:
                          fileitem = form['file']
                          if fileitem.file:
                              filename = f"{timestamp}_{fileitem.filename if hasattr(fileitem, 'filename') and fileitem.filename else 'data.bin'}"
                              file_path = os.path.join(UPLOAD_DIR, filename)
                              with open(file_path, 'wb') as f:
                                  f.write(fileitem.file.read())
                              
                              print(f"[{datetime.now()}] Saved file: {file_path}")
                              print(f"[{datetime.now()}] Size: {os.path.getsize(file_path)}")
                              
                              try:
                                  with open(file_path, 'r') as f:
                                      content = f.read(1000)
                                      print(f"[{datetime.now()}] Content: {content}")
                              except UnicodeDecodeError:
                                  print(f"[{datetime.now()}] Binary file")
                              
                              self._set_headers(200)
                              self.wfile.write(b"File uploaded successfully")
                          else:
                              self._set_headers(400)
                              self.wfile.write(b"No file content")
                      else:
                          content_length = int(self.headers.get('Content-Length', 0))
                          if content_length > 0:
                              post_data = self.rfile.read(content_length)
                              data_file = os.path.join(UPLOAD_DIR, f"{timestamp}_data.bin")
                              with open(data_file, 'wb') as f:
                                  f.write(post_data)
                              print(f"[{datetime.now()}] Raw data saved: {data_file}")
                              print(f"[{datetime.now()}] Data: {post_data[:100]}")
                              
                              self._set_headers(200)
                              self.wfile.write(b"Data received")
                          else:
                              self._set_headers(400)
                              self.wfile.write(b"No data received")
                  except Exception as e:
                      self._set_headers(500)
                      self.wfile.write(str(e).encode())
                      print(f"[{datetime.now()}] Error: {e}")

          httpd = socketserver.TCPServer(("", PORT), CustomHTTPRequestHandler)
          print(f"[{datetime.now()}] Starting server on port {PORT}")
          print(f"[{datetime.now()}] Uploads dir: {UPLOAD_DIR}")
          httpd.serve_forever()
          EOT
          
          # Make it executable
          chmod +x /payloads/server.py
          
          # Start HTTP server
          cd /payloads && python3 server.py &
          
          # Start shell listeners with logging
          /payloads/shell_logger.sh 4444 &
          /payloads/shell_logger.sh 7456 &
          
          # Create a simple echo server on port 4445 for testing basic connectivity
          (while true; do { echo -e "HTTP/1.1 200 OK\n\n$(date) - Simple Echo Server"; } | nc -l -p 4445; done) &
          
          # Keep container running
          tail -f /dev/null
        ports:
        - containerPort: 8080
        - containerPort: 4444
        - containerPort: 4445
        - containerPort: 7456
---
apiVersion: v1
kind: Service
metadata:
  name: payload-server
  namespace: default
spec:
  selector:
    app: payload-server
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  - name: shell1
    port: 4444
    targetPort: 4444
  - name: shell2
    port: 7456
    targetPort: 7456
  - name: echo
    port: 4445
    targetPort: 4445
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: payload-server-instructions
data:
  readme.md: |
    # Payload Server Configuration
    
    This server is designed to simulate a compromised endpoint for testing security countermeasures.
    
    ## Available Services
    
    - **HTTP Server**: Port 8080 - Serves payloads and receives exfiltrated data
    - **Shell Listener 1**: Port 4444 - Primary reverse shell listener
    - **Shell Listener 2**: Port 7456 - Secondary reverse shell listener
    - **Echo Server**: Port 4445 - Simple connectivity test server
    
    ## Environment Variables
    
    The following environment variables can be configured in the deployment:
    
    - `HTTP_PORT`: The port for the HTTP server (default: 8080)
    - `SHELL_PORT_1`: The port for the primary shell listener (default: 4444)
    - `SHELL_PORT_2`: The port for the secondary shell listener (default: 7456)
    
    ## Endpoints
    
    - `/`: Lists available payloads
    - Any file under `/payloads/` can be accessed directly by path
    - `POST` to any path will save the data to `/payloads/uploads/`
    
    ## Accessing Captured Data
    
    Shell connections and uploads are captured in the `/payloads/uploads` and `/payloads/shells` directories.
    
    You can view these files by executing:
    
    ```
    kubectl exec -it $(kubectl get pods -l app=payload-server -o name | head -n1) -- ls -la /payloads/uploads
    kubectl exec -it $(kubectl get pods -l app=payload-server -o name | head -n1) -- ls -la /payloads/shells
    ```
    
    To view a specific file:
    
    ```
    kubectl exec -it $(kubectl get pods -l app=payload-server -o name | head -n1) -- cat /payloads/uploads/FILENAME
    ``` 